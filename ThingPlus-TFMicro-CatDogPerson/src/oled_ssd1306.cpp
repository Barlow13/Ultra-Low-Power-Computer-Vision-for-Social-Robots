#include "oled_ssd1306.h"
#include "pico/stdlib.h"
#include <cstring>

// Standard 5x7 font (ASCII 0x20-0x7F). Each glyph 5 bytes, LSB = top pixel.
const uint8_t g_font5x7[] = {
0x00,0x00,0x00,0x00,0x00, // 0x20 ' '
0x00,0x00,0x5F,0x00,0x00, // 0x21 '!'
0x00,0x07,0x00,0x07,0x00, // 0x22 '"'
0x14,0x7F,0x14,0x7F,0x14, // 0x23 '#'
0x24,0x2A,0x7F,0x2A,0x12, // 0x24 '$'
0x23,0x13,0x08,0x64,0x62, // 0x25 '%'
0x36,0x49,0x55,0x22,0x50, // 0x26 '&'
0x00,0x05,0x03,0x00,0x00, // 0x27 '\''
0x00,0x1C,0x22,0x41,0x00, // 0x28 '('
0x00,0x41,0x22,0x1C,0x00, // 0x29 ')'
0x14,0x08,0x3E,0x08,0x14, // 0x2A '*'
0x08,0x08,0x3E,0x08,0x08, // 0x2B '+'
0x00,0x50,0x30,0x00,0x00, // 0x2C ','
0x08,0x08,0x08,0x08,0x08, // 0x2D '-'
0x00,0x60,0x60,0x00,0x00, // 0x2E '.'
0x20,0x10,0x08,0x04,0x02, // 0x2F '/'
0x3E,0x51,0x49,0x45,0x3E, // 0x30 '0'
0x00,0x42,0x7F,0x40,0x00, // 0x31 '1'
0x42,0x61,0x51,0x49,0x46, // 0x32 '2'
0x21,0x41,0x45,0x4B,0x31, // 0x33 '3'
0x18,0x14,0x12,0x7F,0x10, // 0x34 '4'
0x27,0x45,0x45,0x45,0x39, // 0x35 '5'
0x3C,0x4A,0x49,0x49,0x30, // 0x36 '6'
0x01,0x71,0x09,0x05,0x03, // 0x37 '7'
0x36,0x49,0x49,0x49,0x36, // 0x38 '8'
0x06,0x49,0x49,0x29,0x1E, // 0x39 '9'
0x00,0x36,0x36,0x00,0x00, // 0x3A ':'
0x00,0x56,0x36,0x00,0x00, // 0x3B ';'
0x08,0x14,0x22,0x41,0x00, // 0x3C '<'
0x14,0x14,0x14,0x14,0x14, // 0x3D '='
0x00,0x41,0x22,0x14,0x08, // 0x3E '>'
0x02,0x01,0x51,0x09,0x06, // 0x3F '?'
0x32,0x49,0x79,0x41,0x3E, // 0x40 '@'
0x7E,0x11,0x11,0x11,0x7E, // 0x41 'A'
0x7F,0x49,0x49,0x49,0x36, // 0x42 'B'
0x3E,0x41,0x41,0x41,0x22, // 0x43 'C'
0x7F,0x41,0x41,0x22,0x1C, // 0x44 'D'
0x7F,0x49,0x49,0x49,0x41, // 0x45 'E'
0x7F,0x09,0x09,0x09,0x01, // 0x46 'F'
0x3E,0x41,0x49,0x49,0x3A, // 0x47 'G'
0x7F,0x08,0x08,0x08,0x7F, // 0x48 'H'
0x00,0x41,0x7F,0x41,0x00, // 0x49 'I'
0x20,0x40,0x41,0x3F,0x01, // 0x4A 'J'
0x7F,0x08,0x14,0x22,0x41, // 0x4B 'K'
0x7F,0x40,0x40,0x40,0x40, // 0x4C 'L'
0x7F,0x02,0x0C,0x02,0x7F, // 0x4D 'M'
0x7F,0x04,0x08,0x10,0x7F, // 0x4E 'N'
0x3E,0x41,0x41,0x41,0x3E, // 0x4F 'O'
0x7F,0x09,0x09,0x09,0x06, // 0x50 'P'
0x3E,0x41,0x51,0x21,0x5E, // 0x51 'Q'
0x7F,0x09,0x19,0x29,0x46, // 0x52 'R'
0x46,0x49,0x49,0x49,0x31, // 0x53 'S'
0x01,0x01,0x7F,0x01,0x01, // 0x54 'T'
0x3F,0x40,0x40,0x40,0x3F, // 0x55 'U'
0x1F,0x20,0x40,0x20,0x1F, // 0x56 'V'
0x7F,0x20,0x18,0x20,0x7F, // 0x57 'W'
0x63,0x14,0x08,0x14,0x63, // 0x58 'X'
0x03,0x04,0x78,0x04,0x03, // 0x59 'Y'
0x61,0x51,0x49,0x45,0x43, // 0x5A 'Z'
0x00,0x7F,0x41,0x41,0x00, // 0x5B '['
0x02,0x04,0x08,0x10,0x20, // 0x5C '\\'
0x00,0x41,0x41,0x7F,0x00, // 0x5D ']'
0x04,0x02,0x01,0x02,0x04, // 0x5E '^'
0x40,0x40,0x40,0x40,0x40, // 0x5F '_'
0x00,0x01,0x02,0x04,0x00, // 0x60 '`'
0x20,0x54,0x54,0x54,0x78, // 0x61 'a'
0x7F,0x48,0x44,0x44,0x38, // 0x62 'b'
0x38,0x44,0x44,0x44,0x20, // 0x63 'c'
0x38,0x44,0x44,0x48,0x7F, // 0x64 'd'
0x38,0x54,0x54,0x54,0x18, // 0x65 'e'
0x08,0x7E,0x09,0x01,0x02, // 0x66 'f'
0x0C,0x52,0x52,0x52,0x3E, // 0x67 'g'
0x7F,0x08,0x04,0x04,0x78, // 0x68 'h'
0x00,0x44,0x7D,0x40,0x00, // 0x69 'i'
0x20,0x40,0x44,0x3D,0x00, // 0x6A 'j'
0x7F,0x10,0x28,0x44,0x00, // 0x6B 'k'
0x00,0x41,0x7F,0x40,0x00, // 0x6C 'l'
0x7C,0x04,0x18,0x04,0x78, // 0x6D 'm'
0x7C,0x08,0x04,0x04,0x78, // 0x6E 'n'
0x38,0x44,0x44,0x44,0x38, // 0x6F 'o'
0x7C,0x14,0x14,0x14,0x08, // 0x70 'p'
0x08,0x14,0x14,0x18,0x7C, // 0x71 'q'
0x7C,0x08,0x04,0x04,0x08, // 0x72 'r'
0x48,0x54,0x54,0x54,0x20, // 0x73 's'
0x04,0x3F,0x44,0x40,0x20, // 0x74 't'
0x3C,0x40,0x40,0x20,0x7C, // 0x75 'u'
0x1C,0x20,0x40,0x20,0x1C, // 0x76 'v'
0x3C,0x40,0x30,0x40,0x3C, // 0x77 'w'
0x44,0x28,0x10,0x28,0x44, // 0x78 'x'
0x0C,0x50,0x50,0x50,0x3C, // 0x79 'y'
0x44,0x64,0x54,0x4C,0x44, // 0x7A 'z'
0x08,0x36,0x41,0x41,0x00, // 0x7B '{'
0x00,0x00,0x7F,0x00,0x00, // 0x7C '|'
0x00,0x41,0x41,0x36,0x08, // 0x7D '}'
0x08,0x04,0x08,0x10,0x08, // 0x7E '~'
0x7F,0x41,0x41,0x41,0x7F  // 0x7F (DEL placeholder as full box)
};

bool SSD1306::init(i2c_inst_t* i2c, uint sda, uint scl, uint32_t speed_hz, uint8_t addr) {
    _i2c = i2c; _addr = addr;
    i2c_init(_i2c, speed_hz);
    gpio_set_function(sda, GPIO_FUNC_I2C);
    gpio_set_function(scl, GPIO_FUNC_I2C);
    gpio_pull_up(sda); gpio_pull_up(scl);
    sleep_ms(10);
    // Basic init sequence
    const uint8_t cmds[] = {
        0xAE, // display off
        0x20, 0x00, // horizontal addressing mode
        0x40,       // start line = 0
        0xA1,       // segment remap
        0xC8,       // COM scan dec
        0xA8, (uint8_t)(SSD1306_HEIGHT-1),
        0xD3, 0x00, // display offset
        0xDA, 0x02, // COM pins (for 128x32)
        0x81, 0x7F, // contrast
        0xA4,       // display from RAM
        0xA6,       // normal display
        0xD5, 0x80, // clock
        0x8D, 0x14, // charge pump
        0xAF        // display on
    };
    sendCommands(cmds, sizeof(cmds));
    clear();
    flush();
    _inited = true;
    return true;
}

void SSD1306::sendCommand(uint8_t cmd) {
    uint8_t buf[2] = {0x00, cmd};
    i2c_write_blocking(_i2c, _addr, buf, 2, false);
}
void SSD1306::sendCommands(const uint8_t* cmds, int n) {
    for (int i=0;i<n;i++) sendCommand(cmds[i]);
}

void SSD1306::clear() {
    memset(_buf, 0, sizeof(_buf));
}

inline void SSD1306::setPixel(int x, int y, bool on) {
    if ((unsigned)x >= SSD1306_WIDTH || (unsigned)y >= SSD1306_HEIGHT) return;
    int index = x + (y/8)*SSD1306_WIDTH;
    uint8_t mask = 1u << (y & 7);
    if (_inverted ? !on : on) _buf[index] |= mask; else _buf[index] &= ~mask;
}

void SSD1306::drawChar(int x, int y, char c) {
    if (x > SSD1306_WIDTH - 1 || y > SSD1306_HEIGHT - 1) return;
    if (c < 0x20 || c > 0x7F) c = '?';
    int idx = (c - 0x20) * 5;
    for (int col=0; col<5; ++col) {
        uint8_t line = g_font5x7[idx + col];
        for (int row=0; row<7; ++row) {
            bool on = (line >> row) & 0x1;
            int px = x + col;
            int py = y + row;
            setPixel(px, py, on);
        }
    }
}

void SSD1306::drawText(int x, int y, const char* text) {
    while (*text) {
        drawChar(x, y, *text++);
        x += 6; // 5px glyph +1 space
        if (x > SSD1306_WIDTH - 6) { x = 0; y += 8; if (y > SSD1306_HEIGHT - 8) break; }
    }
}

void SSD1306::drawHLine(int x, int y, int w) {
    for (int i=0;i<w;i++) setPixel(x+i,y,true);
}

void SSD1306::invert(bool inv) {
    _inverted = inv;
    sendCommand(inv ? 0xA7 : 0xA6);
}

void SSD1306::power(bool on) {
    if (!_inited) return;
    if (_powered == on) return;
    // 0xAE = display off, 0xAF = display on
    sendCommand(on ? 0xAF : 0xAE);
    _powered = on;
    // When powering back on, resend buffer so screen shows last state
    if (on) flush();
}

void SSD1306::sendBuffer() {
    // Set column & page ranges then send entire buffer in chunks.
    uint8_t setup[] = {0x21,0,SSD1306_WIDTH-1, 0x22,0,(uint8_t)((SSD1306_HEIGHT/8)-1)};
    for (int i=0;i<sizeof(setup);++i) sendCommand(setup[i]);
    for (int offset=0; offset < (int)sizeof(_buf); ) {
        uint8_t chunk[17];
        chunk[0] = 0x40; // data control
        int n = 16; if (offset + n > (int)sizeof(_buf)) n = sizeof(_buf) - offset;
        memcpy(&chunk[1], _buf + offset, n);
        i2c_write_blocking(_i2c, _addr, chunk, n+1, false);
        offset += n;
    }
}

void SSD1306::flush() {
    if (!_inited) return;
    sendBuffer();
}
